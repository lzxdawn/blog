<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue生命周期</title>
      <link href="/2020/02/24/vue-gouzi/"/>
      <url>/2020/02/24/vue-gouzi/</url>
      
        <content type="html"><![CDATA[<p>如果只是单纯地知道vue里面的简单语法，你是可以实现对应的一些项目和对应的想法，但是如果一旦发生问题，我们就需要借助生命周期去寻找问题，甚至说有一些需求的话，你也通过生命周期的情况来定我们该把这个东西写在哪里。所以理解vue的生命周期还是很有必要的。</p><pre><code>vue的生命周期就是每个vue实例被创建之前一直到结束经历的一系列的初始化过程。下面是官网关于vue生命周期的图解，</code></pre><p>  <img src="https://img-blog.csdn.net/20180422162717814?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdGxwX2NzZG4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><pre><code>可以看出在vue整个生命周期中会有很多钩子函数（图中标红的部分），虽然我们用到的就那么几个，但我们都来了解一下。首先先明白一个概念：Vue的实例。它是Vue框架的入口，可以理解为前端的ViewModel，它包含它包含了页面中的业务逻辑处理、数据模型等，它也有自己的一系列的生命周期的函数钩子，辅助我们进行对整个Vue实例生成、编译、挂着、销毁等过程进行js控制。</code></pre><p>1、beforeCreated（）</p><p>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。（这里是在index.html里做的测试）</p><p>  <img src="https://img-blog.csdn.net/20180422193606751?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdGxwX2NzZG4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>2、created（）</p><p>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p><p>  <img src="https://img-blog.csdn.net/20180422193745868?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdGxwX2NzZG4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>3、beforeMount（）</p><p>在挂载开始之前被调用：相关的 render 函数首次被调用。</p><p>  <img src="" alt="img"></p><p>4、mounted（）</p><p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</p><p>  <img src="https://img-blog.csdn.net/20180422194016807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdGxwX2NzZG4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>5、beforeUpdate（）</p><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p><p>6、updated（）</p><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p><p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p><p>该钩子在服务器端渲染期间不被调用。</p><p>7、beforeDestroy（）</p><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p><p>8、destroyed（）</p><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。<br>————————————————</p><p>原文链接：<a href="https://blog.csdn.net/jitlp_csdn/article/details/80040000" target="_blank" rel="noopener">https://blog.csdn.net/jitlp_csdn/article/details/80040000</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS防抖和节流</title>
      <link href="/2020/02/23/fangdou-jieliu/"/>
      <url>/2020/02/23/fangdou-jieliu/</url>
      
        <content type="html"><![CDATA[<hr><p>日常开发过程中，滚动事件做复杂计算频繁调用回调函数很可能会造成页面的卡顿，这时候我们更希望把多次计算合并成一次，只操作一个精确点，JS把这种方式称为debounce（防抖）和throttle（节流）</p><h2 id="1-函数防抖-debounce"><a href="#1-函数防抖-debounce" class="headerlink" title="1.函数防抖(debounce)"></a>1.函数防抖(debounce)</h2><p>​    当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定时间到来之前，又触发了事件，就重新开始延时。也就是说当一个用户一直触发这个函数，且每次触发函数的间隔小于既定时间，那么防抖的情况下只会执行一次。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="2-函数节流-throttle"><a href="#2-函数节流-throttle" class="headerlink" title="2.函数节流(throttle)"></a>2.函数节流(throttle)</h2><p>​    当持续触发事件时，保证在一定时间内只调用一次事件处理函数，意思就是说，假设一个用户一直触发这个函数，且每次触发小于既定值，函数节流会每隔这个时间调用一次<br>用一句话总结防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行<br>实现函数节流我们主要有两种方法：时间戳和定时器</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> lastTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">var</span> nowTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>nowTime <span class="token operator">-</span> lastTime <span class="token operator">></span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>        func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>        lastTime <span class="token operator">=</span> nowTime<span class="token punctuation">;</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><pre class=" language-html"><code class="language-html">函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写博客必备神器</title>
      <link href="/2020/02/22/blog-tools/"/>
      <url>/2020/02/22/blog-tools/</url>
      
        <content type="html"><![CDATA[<p><a href="https://lzxdawn.github.io/tags/%E5%8D%9A%E5%AE%A2/">博客</a></p><p><a href="https://lzxdawn.github.io/tags/%E5%B7%A5%E5%85%B7/">工具</a></p><p>完成了博客的搭建之后，接下来就是是内容创作了。而创作的过程中，我们又会有一系列的问题，比如：</p><ul><li>我们用什么工具来编写文章呢？</li><li>怎么才能快速生成格式化的Markdown表格？</li><li>怎么样才能画出一些高逼格的图片呢？</li><li>这些图片的存储和处理怎么办呢？文章中的代码高亮如何实现呢？</li></ul><p>要解决这些问题其实并不难，无非就是引入不同的工具来帮助我们，好的工具可以让我们的创作事半功倍！</p><h2 id="Markdown编辑器"><a href="#Markdown编辑器" class="headerlink" title="Markdown编辑器"></a>Markdown编辑器</h2><p>先来推荐一下我们要用的最重要的一个工具：Marddown编辑器。我们需要使用它来完成所有的创作内容，本人尝试了非常多的编辑器，最终锁定在下面这款Typora，因此推荐给大家。</p><ul><li>推荐工具：Typora</li><li>官方地址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></li><li>推荐理由：作为一款免费编辑器，可以说是相当的良心，是我目前所知道的最好用的免费编辑器了，没有之一！！！它支持多个主流的操作系统，不论你是Windows用户还是Mac用户，都能轻易的安装和使用它！除此之外，它还有多种不同的主题选择、导出一些常用格式（PDF、Word、HTML）等等非常有用的功能！</li></ul><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5tfro5t1dj30m80ggt9m.jpg" alt="img"></p><h2 id="Markdown表格生成器"><a href="#Markdown表格生成器" class="headerlink" title="Markdown表格生成器"></a>Markdown表格生成器</h2><p>对于强迫症来说，写Markdown表格是一件很痛苦的事情，在语法对齐的问题上我真的是受尽了折磨，所以强烈推荐一个在线Markdown表格生成工具，它除了能快速生成格式化后的Markdown表格外，还支持导入各种数据，在线编辑，简直强大！</p><ul><li>推荐工具：Table Convert Online</li><li>官方地址：<a href="https://tableconvert.com/" target="_blank" rel="noopener">https://tableconvert.com/</a></li><li>推荐理由：作为一款免费在线工具，支持Excel、JSON、HTML、CSV甚至是从URL中提取HTML表格转为Markdown表格，多功能集一身，并且融合在一个界面，使用非常方便，不需要切换页面。还可以像编辑Excel一样编辑生成各种表格，不愧为表格中的瑞士军刀！</li></ul><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5tfrx6iz5j30yg0kudhs.jpg" alt="img"></p><h2 id="画图工具"><a href="#画图工具" class="headerlink" title="画图工具"></a>画图工具</h2><p>对于我们这些写技术文章的博主来说，画画流程图、架构图是辅助描述文章内容的最佳途径，下面要推荐的ProcessOn就是目前我用得最多的画图工具。</p><ul><li>推荐工具：ProcessOn</li><li>官方地址：<a href="https://www.processon.com/i/55d92963e4b0b89615a284e2" target="_blank" rel="noopener">https://processon.com/</a></li><li>推荐理由：难得的国产在线图片编辑器，支持多人协作。同时，还有大量好看的图标支持，可以让我们的绘图更加生动！</li></ul><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5tfs42rkxj30m80e4wfc.jpg" alt="img"></p><h2 id="图片存储"><a href="#图片存储" class="headerlink" title="图片存储"></a>图片存储</h2><p>可能有人会问，为什么要图片存储呢？我们直接存Wordpress或者Hexo的目录下不就好了吗？实际上，使用这些主要是为了经济性的考虑，随着访问量的增大，图片对于我们的虚拟主机或ECS的空间以及带宽消耗都会造成一定的压力，使用类似图床的平台可以帮我们减轻这些压力。</p><ul><li>推荐工具：外链工厂</li><li>官方地址：<a href="http://www.wailian.work/" target="_blank" rel="noopener">http://www.wailian.work/</a></li><li>推荐理由：简单好用、足够稳定，释放自己虚拟空间或虚拟主机的存储和带宽消耗，但是记得做好备份哦！</li></ul><p><img src="http://s1.wailian.download/2020/02/22/QQ20200222224353.png" alt="QQ20200222224353.png"></p><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>如果你跟我一样是一名程序猿，那么代码高亮是必备的。大多Hexo的主题中都包含了高亮插件，但是有些并没有，那么我们需要知道鼎鼎大名的hightlight.js。对于一些已经有这个插件的主题，也可以通过官网来做一些定制，没有的直接引入来使用即可。</p><ul><li>推荐工具：hightlight.js</li><li>官方地址：<a href="https://highlightjs.org/" target="_blank" rel="noopener">https://highlightjs.org/</a></li><li>推荐理由：适用于所有主流编程语言，兼容性好，多种多样的预设样式，总有一款适合你！</li></ul><p>![l01.jpg](<a href="http://s1.wailian.download/2020/02/22/ml01.jpg" target="_blank" rel="noopener">http://s1.wailian.download/2020/02/22/ml01.jpg</a></p><p><a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/one-command-deployment.html</a>)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
